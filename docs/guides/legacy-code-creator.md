# レガシーコード解析 - 制作者向け手順書

**最終更新**: 2025-12-17

## はじめに

この手順書は、**あなた自身が過去に作成したゲームのレガシーコード**を仕様書駆動フレームワークで再構築するための実践的なガイドです。

10年以上前に書いたコードは、細部の記憶が曖昧になっているかもしれません。しかし、**あなたの記憶とlegacy-analyzer-agentの協力**により、効率的に仕様を再構築できます。

## あなたの役割

### 制作者として期待されること

1. **大局的な記憶の提供**
   - ゲームの全体的なコンセプト
   - 主要なメカニクスの意図
   - 重要なアルゴリズムの方針

2. **エージェントの解析結果の確認**
   - 推測部分が正しいかの確認
   - 不明点の補完（可能な範囲で）

3. **優先順位の判断**
   - どのサブシステムから解析すべきか
   - どのアルゴリズムが重要か

### 完璧を求めない

**重要**: 細部まで完全に思い出す必要はありません。

- 「覚えていない」→ 「不明」とマーク
- 「たぶん〜だった」→ 「推測」として記述
- 「コードを見ればわかる」→ エージェントに解析を依頼

---

## 事前準備

### 1. 心の準備

10万行のコードを見ると圧倒されるかもしれませんが、**一度に全部を理解する必要はありません**。

段階的に進めます：
1. まず全体像（Phase 1）
2. 次に各部分（Phase 2）
3. 最後に重要な詳細（Phase 3）

### 2. 思い出しておくこと

解析を始める前に、以下を軽く思い出してください：

- [ ] ゲームのジャンルは？（RPG、アクション、パズル等）
- [ ] どんな技術を使っていたか？（OpenGL、SDL等）
- [ ] どんな機能があったか？（戦闘、探索、アイテム等）
- [ ] 特にこだわった部分は？

**メモを取ることをお勧めします**。

---

## Phase 1: 粗視化解析（1-2週間）

### あなたがすること

#### Step 1: エージェントに解析を依頼

```
あなた: 「legacy-analyzer-agentを使って、エントリーポイントを特定して」
```

エージェントが `901_reference_game/overview.md` を作成します。

#### Step 2: 生成された overview.md を確認

エージェントが推測した内容を確認してください：

```markdown
## ゲーム概要（推測）

2DアクションRPG。プレイヤーはダンジョンを探索し...

**確認事項**:
- [ ] このゲーム概要は正しいですか？
```

#### Step 3: 記憶を元に補完

**記憶がある部分**:
- 推測を確定情報に変更
- 不足している情報を追加

**記憶が曖昧な部分**:
- 「推測」としてマークのまま
- または「不明」とマーク

**例**:
```markdown
## ゲーム概要

2DアクションRPG。プレイヤーはダンジョンを探索し、敵と戦い、
アイテムを集めながら進行する。

**補完（制作者記憶）**:
- 全10ステージ
- ボスキャラは各ステージに1体
- エンディングは2種類（確か...）
```

### 注意点

- **完璧を求めない**: 覚えていないことは無理に思い出さない
- **コードに頼る**: 「コードを見ればわかる」ならエージェントに依頼
- **メモを残す**: 思い出したことはその場でメモ

---

## Phase 2: 詳細解析（2-4週間）

### あなたがすること

#### Step 1: 解析の優先順位を決定

**質問**: どのサブシステムから解析したいですか？

推奨順序：
1. ゲームロジック（最重要）
2. データ構造
3. UI/画面構成
4. レンダリング
5. 入力処理

あなたの判断で優先順位を変更してもOKです。

#### Step 2: サブシステムごとに解析を依頼

**例（ゲームロジック）**:
```
あなた: 「ゲームロジックサブシステムを詳細に解析して」
```

エージェントが `901_reference_game/mechanics/` に文書を作成します。

#### Step 3: 生成された文書を確認

エージェントが推測した処理フローを確認：

```markdown
## GameState クラス

**処理フロー（推測）**:
1. update() でゲーム状態を毎フレーム更新
2. イベント発生時に handleEvent() を呼び出し
3. 状態遷移は内部のステートマシンで管理

**確認事項**:
- [ ] ステート遷移の詳細を教えてください
- [ ] イベントの種類を教えてください
```

#### Step 4: 記憶を元に補完

**あなたができること**:
- ステートの種類を列挙（例: TITLE, GAME, MENU, GAMEOVER）
- イベントの種類を列挙（例: PLAYER_DAMAGED, ENEMY_DEFEATED）
- 処理の意図を説明

**例**:
```markdown
**制作者による補完**:

ステートの種類:
- TITLE: タイトル画面
- GAME: ゲーム中
- MENU: メニュー画面
- GAMEOVER: ゲームオーバー

イベントの種類（覚えている範囲）:
- PLAYER_DAMAGED: プレイヤーがダメージを受けた
- ENEMY_DEFEATED: 敵を倒した
- ITEM_ACQUIRED: アイテムを取得した
- その他（不明）
```

### 作業のリズム

**推奨**:
- 1サブシステムにつき1日〜1週間
- 疲れたら休憩
- 思い出せないことは無理しない

---

## Phase 3: アルゴリズム抽出（1-2週間）

### あなたがすること

#### Step 1: 重要なアルゴリズムをリストアップ

**質問**: どのアルゴリズムが特に重要でしたか？

よくある例：
- 戦闘システム
- AI
- 物理演算
- スコア計算
- セーブ/ロード

**あなたがこだわった部分を優先してください。**

#### Step 2: アルゴリズムごとに解析を依頼

**例（戦闘システム）**:
```
あなた: 「戦闘システムのダメージ計算を詳細に解析して」
```

エージェントが詳細な解析結果を提示します。

#### Step 3: 数式やロジックを確認

エージェントがコードから抽出した数式を確認：

```markdown
## ダメージ計算式（コードから抽出）

```cpp
int damage = attacker->attack - defender->defense;
if (damage < 1) damage = 1;
```

**確認事項**:
- [ ] クリティカルヒットの有無
- [ ] 属性相性の有無
- [ ] 乱数要素の範囲
```

#### Step 4: 意図を説明

**あなたができること**:
- 「なぜこの式にしたか」を説明
- 「他に考慮していた要素」を追加
- 「当時の設計判断」を記録

**例**:
```markdown
**制作者による補完**:

この計算式は、シンプルさを重視して設計しました。

当時の設計判断:
- クリティカルヒットは実装していない（時間不足）
- 属性相性も未実装（将来の拡張として考えていた）
- 最低ダメージ1は、防御が高すぎて倒せない問題を避けるため

乱数要素:
- たしか、最終ダメージに ±20% の乱数を加えていたはず
  （コード確認が必要）
```

---

## Phase 4: 新規仕様の作成（1-2週間）

### あなたがすること

#### Step 1: 9_reference の内容を確認

これまでに作成した `901_reference_game/` の内容を全体的に確認してください。

#### Step 2: 改善点をリストアップ

**質問**: 今回の再実装で、何を改善したいですか？

よくある改善例：
- 技術スタックの刷新（C++ → TypeScript等）
- 複雑すぎたシステムのシンプル化
- 未実装だった機能の追加
- パフォーマンス改善

**あなたのリストを作成してください**:

```markdown
## 改善点

1. レンダリング: OpenGL → WebGL（ブラウザで動かしたい）
2. データ形式: バイナリ → JSON（可読性向上）
3. 戦闘システム: シンプル化（複雑すぎた）
4. セーブ/ロード: 追加実装（当時は未実装）
5. UI: 改善（当時は見づらかった）
```

#### Step 3: requirements-agentに要件定義を依頼

```
あなた: 「requirements-agentを使って、改善版の要件定義を作成して。
         改善点は以下の通り: [リストを提示]」
```

エージェントが `3_ingame/30100_requirements.md` を作成します。

#### Step 4: 要件定義を確認

生成された要件定義を確認し、必要に応じて修正してください。

---

## よくある質問（FAQ）

### Q1: 記憶が曖昧すぎて、ほとんど思い出せません

**A**: 問題ありません。

- エージェントがコードから推測します
- 推測で「たぶんこうだろう」を記録します
- 新規仕様で改善方向を決定すればOKです

**重要**: 完全な再現ではなく、**新しいゲームを作る**のが目的です。

### Q2: コードが複雑すぎて、自分でも理解できません

**A**: よくあることです。

対処法：
1. エージェントに小さな単位で解析してもらう
2. 「このクラスは何をしているか」を説明してもらう
3. どうしても理解できない部分は「不明」とマーク
4. 新規仕様ではシンプルに作り直す

### Q3: Phase 2, 3 が時間かかりすぎます

**A**: 無理に全部やる必要はありません。

**最低限必要なもの**:
- ゲームの全体像（Phase 1）
- 主要なゲームロジック（Phase 2の一部）
- あなたがこだわった部分（Phase 3の一部）

**それ以外**: 「不明」として、新規仕様で作り直せばOKです。

### Q4: 新技術スタックで実装できるか不安です

**A**: 実装は後回しでOKです。

今やること：
1. レガシーコードの仕様を記録
2. 新規仕様を作成

実装は、仕様書駆動システムが完成してから、impl-agentと一緒に進めます。

---

## 作業のペース配分

### 推奨スケジュール

| Phase | 期間 | 週あたりの作業時間 |
|-------|------|------------------|
| Phase 1 | 1-2週間 | 5-10時間 |
| Phase 2 | 2-4週間 | 5-10時間 |
| Phase 3 | 1-2週間 | 3-5時間 |
| Phase 4 | 1-2週間 | 5-10時間 |

**合計**: 5-10週間、週5-10時間程度

### 無理のないペースで

- **焦らない**: 10万行のコードは一度に理解できません
- **休憩を取る**: 疲れたら休む
- **完璧を求めない**: 不明点は「不明」でOK

---

## チェックリスト

### Phase 1 完了時

- [ ] overview.md を確認し、記憶を元に補完した
- [ ] ゲームの全体像を理解した
- [ ] 主要なサブシステムを把握した

### Phase 2 完了時

- [ ] 重要なサブシステムを解析した
- [ ] データ構造を理解した
- [ ] 各サブシステムの意図を説明した

### Phase 3 完了時

- [ ] 重要なアルゴリズムを解析した
- [ ] 設計判断を記録した
- [ ] 数式やロジックを確認した

### Phase 4 完了時

- [ ] 改善点をリストアップした
- [ ] 要件定義を確認した
- [ ] 新規仕様の方向性が定まった

---

## 心構え

### 思い出せないことを恐れない

10年以上前のコードを完全に思い出すことは不可能です。

- **思い出せないこと**: 当然
- **推測で補完**: OK
- **新規仕様で改善**: 本来の目的

### 過去の自分に感謝する

レガシーコードは、過去のあなたが作った貴重な資産です。

- 完璧ではないかもしれませんが、それが成長の証
- 今のあなたなら、もっと良いものが作れる
- レガシーコードは「参考資料」として活用

### これは「発掘」作業

レガシーコード解析は、考古学のようなものです。

- 発掘（Phase 1-3）
- 研究（Phase 4）
- 新しい創造（Phase 5: 実装）

楽しみながら進めてください。

---

## 困ったときは

### エージェントに質問する

```
あなた: 「このクラスは何をしているの？」
あなた: 「この関数の意図は？」
あなた: 「このアルゴリズムをシンプルに説明して」
```

### ドキュメントを参照する

- [レガシーコード解析ガイド](./legacy-code-analysis.md)
- [legacy-analyzer-agent](../../agents/legacy-analyzer-agent.md)
- [9_reference Overview](../9_reference/90000_overview.md)

### 焦らず、着実に

このフレームワークは、あなたの作業を支援するために作られています。

焦らず、着実に進めてください。

---

**最後に**: あなたが過去に作ったゲームを、最新の技術で蘇らせるこのプロジェクト、成功を祈っていますわ！
