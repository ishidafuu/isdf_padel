# 設計判断集

本ドキュメントは、仕様書駆動開発フレームワークの設計判断とその理由を記録します。

---

**対象読者**: フレームワークの設計意図を理解したい開発者
**所要時間**: 30分
**前提知識**: [フレームワーク仕様書](./framework-spec.md)の全体像
**次に読むべき**: [フレームワーク開発ガイド](../framework-development/guide.md)

---

## 概要

本フレームワークで意図的にスキップ・簡略化している事項と、その理由を記載する。

---

## 設計判断の補足

### ハードコーディング禁止原則

**判断**: 調整可能な全てのパラメータ値はハードコーディングを禁止し、外部データファイル化を必須とする

**理由**:
- **調整コスト**: コード修正 → コンパイル → テストのサイクルは非効率
- **非エンジニアの調整**: プランナー・デザイナーがバランス調整に参加できる
- **ホットリロード**: 実行中にパラメータを変更して即座に確認できる
- **環境別設定**: 開発環境・テスト環境・本番環境で異なる値を使用可能

**適用範囲**:
- 物理パラメータ（重力、摩擦係数、バウンド係数）
- 移動パラメータ（最大速度、加速度、ジャンプ力）
- サイズ・範囲（コートサイズ、当たり判定半径）
- 時間（無敵時間、入力バッファ時間）
- ゲームバランス（ダメージ、得点、ボール速度）

**例外**（ハードコーディング可能）:
- 数学定数（`Math.PI`, `Math.E`）
- ビルトイン定数（`Vector3.Zero`, `Color.White`）
- 実装ロジックの定数（配列サイズ、ループ回数）

**実装方針**:
- データ配置: `project/docs/8_data/` に定義
- フォーマット: Godot Resource（`.tres`）または JSON/YAML
- ロード: GameConfig Resource として起動時に読み込み
- アクセス: System に GameConfig を依存注入

**ドキュメント記載ルール**:
```markdown
✅ 良い例:
- 重力: `config.Physics.Gravity` (デフォルト: -9.8 m/s²)

❌ 悪い例:
- 重力: -9.8 m/s²
```

具体的な値は参考値として示すが、実装時は必ず設定ファイル参照であることを明記する。

---

### 番号体系のヘルパーコマンド

**判断**: `/id-calc` のような計算コマンドは作成しない

**理由**: 計算ルールは「番号体系」セクションで明文化済み。個人開発では数回使えば体得できるレベルであり、コマンド追加は過剰。

---

### サブフォルダ番号の割り当て基準

**判断**: 厳密な割り当てルールは設けない（例: 208, 209 の根拠）

**理由**: 番号は一意性確保が目的。意味を持たせると拡張時に困る。連番で埋める必要はなく、将来の拡張用に番号を空けておくことも許容する。

---

### REQ-ID の粒度ガイドライン

**判断**: 厳密な粒度ルールは設けない

**理由**: 「1つの REQ = 1つのユーザー視点の振る舞い」は理想的だが、文脈依存で判断が分かれる（例: 「ジャンプできる」と「二段ジャンプできない」を分けるか）。テストと同様「迷ったら分ける」で運用し、問題が出たら基準を厳格化する。

---

### イベントシステムの具体例

**判断**: フレームワーク仕様書には具体的な実装パターン例を記載しない

**理由**:
- イベントシステムの実装パターンはエンジン（Unity/Godot）に依存する
- 具体例を書くとフレームワークがエンジン固有になる
- 詳細は実プロジェクトの `20005_event_system.md` で定義する想定

---

### イベントシステムの抽象パターン名

**判断**: 「Observer / Pub-Sub」等の抽象パターン名も記載しない

**理由**:
- 「Observer / Pub-Sub」は一般的すぎて記載の価値が低い
- Unity/Godot の具体例（UnityEvent, Signal）を書くとエンジン依存になる
- 実プロジェクトの `20005_event_system.md` で具体的に書けば十分

---

### イベント処理のタイミング（バッファリング）

**判断**: ゲームロジックに影響するイベントはバッファリング必須、演出系は即座処理を許容

**理由**:
- **相打ち問題**: 即座処理では Entity/System の実行順序で優劣が決まる
  - 例: CharacterCollisionSystem が PlayerA → PlayerB の順で処理すると、PlayerA が先に無敵になり PlayerB は一方的にダメージを受ける
  - バッファリングにより、同一フレーム内の全イベントを収集してから一括処理することで公平性を保証
- **決定論的挙動**: 処理順序に依存しない一貫した挙動を実現
- **デバッグ性**: イベント処理のタイミングが明確で追跡しやすい

**分類基準**:

| 種別 | 処理方法 | 理由 | 例 |
|------|---------|------|---|
| **ゲームロジック** | バッファリング必須 | 公平性・決定論が必要 | ヒット判定、ふっとばし、スコア |
| **演出系** | 即座処理を許容 | 順序が結果に影響しない | 効果音、エフェクト、アニメーション |

**実装パターン（推奨）**:
1. **System実行フェーズ**: イベント発行（EventBus のバッファに蓄積）
2. **イベント処理フェーズ**: `EventBus.ProcessEvents()` で全イベントを一括処理
3. 演出系のみ必要に応じて即座処理（別の EventBus または Signal を使用）

**相打ち対策**:
- 無敵時間の活用: 既に `Invincible` コンポーネントがある Entity はヒット判定をスキップ
- 同時処理: バッファ内の全 `BallHitEvent` を処理してから、全 Entity に同時に無敵を付与

**詳細**: 実プロジェクトの `20005_event_system.md` に具体的な実装を記載

---

### 並行作業時のID競合対策

**判断**: 複数人での同時編集による ID 採番競合の対策は実装しない

**理由**: 本フレームワークは個人開発を主対象としている。複数人開発が必要になった時点で検討する。

---

### 仕様書へのバージョン埋め込み

**判断**: 各仕様書に「導入バージョン」「最終更新バージョン」などのメタ情報は持たせない

**理由**:
- Git 履歴で追跡可能
- 仕様書内にバージョンを書くと更新漏れが発生しやすい
- 必要であれば Git タグ（`git tag v0.2 -m "説明"`）で管理する

---

### 変更履歴の日付

**判断**: 変更履歴表の日付欄は空欄のままとする

**理由**:
- フレームワーク仕様書はテンプレートとしての性質が強い
- 実プロジェクトでは Git コミット日時で追跡可能
- 日付を入れると「いつの時点の仕様か」という管理コストが増える
- 必要であれば実プロジェクト採用時に記入すればよい

---

### overview.md の命名統一

**判断**: 親フォルダ直下（例: `30000_overview.md`）と機能フォルダ内（例: `30100_player_overview.md`）で `overview` の名前を統一して使用する

**理由**:
- ファイル名に機能名（`_player_`）が含まれるため区別可能
- `index.md` 等の別名にすると番号体系が崩れる
- 親フォルダ直下は「層全体の目次」、機能フォルダ内は「機能の概要」という役割の違いは文脈から明らか

---

### テストIDの番号混在

**判断**: 異なるフォルダの REQ を検証する場合も、テストIDは test.md のファイル番号を使用する（番号の混在を許容）

**理由**:
- 統合テスト用フォルダ（例: `309_integration/`）の導入は個人開発では過剰
- `**検証対象**` フィールドでクロスリファレンスを明示すれば追跡可能
- 実際に混乱が生じた時点で再検討する

---

### コマンド引数の詳細仕様

**判断**: フレームワーク仕様書にはコマンドの入出力例を詳細に記載しない

**理由**:
- フレームワーク仕様書はコマンドの「存在と目的」を示すもの
- 詳細な入出力例は各コマンドファイル（`.claude/commands/*.md`）の責務
- 実プロジェクトでコマンドを実装する際に具体例を記載する

---

### コマンド引数パターンの統一

**判断**: `[arg]` `[--option]` `<value>` 等の記法ルールを厳密に定義しない

**理由**:
- 個人開発では各コマンドファイルで説明すれば十分
- 統一ルールを設けると、新コマンド追加時の認知負荷が増える
- 問題が発生したら検討する

---

### balance 種別の境界

**判断**: balance と spec 変更の厳密な境界定義は行わない

**理由**:
- 実際には「spec に書くほどでもないパラメータ」が多く存在する（例: アニメーション速度、SE の音量）
- 現実的な運用基準として:
  - `balance`: 8_data/ のテーブル値変更、ゲームプレイに影響しない微調整、試行錯誤中の値
  - `spec 更新`: 要件として固定したい値、他の仕様に影響する値
- 迷ったら spec を更新する方針で運用し、問題が出たら基準を厳格化する

---

### 共有Componentの逆参照管理

**判断**: 共有 Component の `.md` に「使用箇所」セクションは持たせない

**理由**:
- 手動管理では更新漏れが発生しやすい
- `/id-refs` でファイルパスや Component 名を検索すれば参照箇所を特定可能
- 検索ベースの運用のほうが安全で保守コストが低い

---

### オフライン作業時の指針

**判断**: フレームワーク仕様書には記載しない

**理由**:
- 個人開発でオフライン環境が長期間続くケースは稀
- Git commit は可能なので、後から Issue 紐付けすれば済む
- 運用ルールを増やすと複雑化する
- 問題が実際に発生したら検討する

---

### Skills拡張（DbC, stateDiagram, BDD）

**判断**: 追加しない（EARSのみ維持）

**理由**:
- EARS記法は「要件の書き方」という独自性が高く、ガイドが必要
- DbC（事前/事後/不変条件）は spec.md テンプレート内に例示済み
- Mermaid stateDiagram は公式ドキュメントで十分
- BDD（Given/When/Then）は test.md テンプレート内に例示済み
- Skills を増やすと「どれを見ればいいか」の判断コストが増える

---

### データ層移行トリガーの定量基準

**判断**: 定量基準を設けない

**理由**:
- 「50行」「3箇所参照」などの数値は根拠が薄い
- プロジェクト特性によって適切な閾値が異なる
- 定量基準を設けると「基準以下だから移行しない」という硬直化を招く
- 「不便を感じたら移行」で十分

---

### /docs-validate の実装優先度

**判断**: P1/P2/P3 などの優先度は設けない

**理由**:
- /docs-validate は「コマンドの目的と検証項目」を示すもの
- 実装優先度は実プロジェクトの状況に依存する
- フレームワーク仕様書で優先度を決めると、プロジェクトごとの判断を縛る
- 実装時に自然と「簡単なものから」進めれば良い

---

### セルフレビューの観点

**判断**: フレームワーク仕様書には記載しない

**理由**:
- 「1日置いて読み返す」等は一般的なベストプラクティス
- フレームワークで強制すべき内容ではない
- 個人の作業スタイルに依存する

---

### CI/CD との統合指針

**判断**: フレームワーク仕様書には記載しない

**理由**:
- `/docs-validate` は手動実行を前提としている
- CI/CD 統合は実プロジェクトの技術スタックに依存する
- 個人開発では手動実行で十分なケースが多い
- 必要になった時点で実プロジェクトの README 等に記載すればよい

---

### フレームワークのマイグレーション指針

**判断**: メジャーバージョンアップ時の移行手順は記載しない

**理由**:
- 破壊的変更の内容が事前に予測できない
- 移行手順は変更内容に依存する
- 変更履歴に破壊的変更を明記し、その都度対応を検討する

---

### 複数人開発への拡張パス

**判断**: 詳細な拡張指針は記載しない

**理由**:
- 本フレームワークは個人開発を主対象としている
- 複数人開発では ID 競合、レビュープロセス、権限管理など別の考慮が必要
- 「設計判断の補足」で個人開発前提を明記しているため、必要時に再設計する想定

---

### 親フォルダ番号の拡張

**判断**: 現状の1桁（1-9）を維持

**理由**:
- 個人開発の規模では 9 フォルダで十分（現状 5 使用、残り 4）
- 枯渇した場合の逃げ道: 親番号を2桁化し6桁体系に移行（例: 10 → 100xxx）
- その際は破壊的変更としてメジャーバージョンアップ（v3）で対応

---

### 8_data と design.md の関係性

**判断**: design.md に「データソース参照」セクションは設けない

**理由**:
- design.md は「データ構造のみ」という原則を維持したい
- データの流し込みは behavior.md の初期化 System で `@data` コメントを使って参照する運用で対応可能
- 実装コメント規約（`// @data 80101_enemy_params.md#enemy_slime`）で十分カバーできる
- 実際に AI が迷う問題が頻発した場合に再検討する

---

### behavior.md のイベント記述標準

**判断**: EARS 記法の拡張（`THEN THE SYSTEM SHALL Publish [EventName]`）は行わない

**理由**:
- イベント発行の記法は実プロジェクトの `20005_event_system.md` で定義すべき内容
- フレームワーク仕様書で EARS 記法を拡張すると、EARS の標準から逸脱する
- イベント設計はエンジン（Unity/Godot）に依存するため、汎用フレームワークでは抽象度を維持する

---

### System のフィルタ条件の記法

**判断**: `With<T>/Without<T>` のような具体的な記法ではなく、自然言語で記述する

**理由**:
- `With<T>/Without<T>` は Unity DOTS / Arch 固有の記法
- Godot はノードベースで ECS クエリの概念が異なる
- 自然言語で書けば、エンジン実装時に各自で適切な形式に変換できる
- エンジン非依存というフレームワークの設計方針を維持する

---

### 1フォルダ1機能セットの原則

**判断**: 同一フォルダ内に複数の機能セット（spec/design/behavior/test）を配置することを禁止する

**理由**:
- ファイル番号（xx01-xx04）と機能セットの1対1対応を維持するため
- `30105_player_input_spec.md` のような「2つ目の機能セット」を許容すると、番号体系の予測可能性が失われる
- 機能が複雑化した場合は、フォルダを分割（例: `301_player_movement/`, `304_player_combat/`）することで対応する
- この制約により、「フォルダ番号を見れば機能セットの構成がわかる」という一貫性を保証する

---

### タスク登録とタスク管理の責務分離

**判断**: タスク作成を「タスク登録」と「タスク管理」の2つのガイドラインに分離する

**背景（v2.11）:**
当初、task-manager-agentが「タスク作成」と「タスクライフサイクル管理」の両方を担当していた。しかし、以下の問題が発生:
- プランファイル → タスクファイル変換のロジックが複雑化
- タスク状態遷移（開始/完了）の処理と混在
- 責務が曖昧になり、ガイドラインが肥大化

**分離後の責務:**
- **task-registration.md**: プランファイル → タスクファイル変換専門
  - プランファイル検出
  - タスクタイプ判定（framework/game-dev/cross-project）
  - ID採番
  - タスクファイル作成
- **task-manager-agent**: タスクライフサイクル管理専門
  - 状態遷移（todo → in-progress → in-review → done）
  - worktree作成・管理（game-devタスクのみ）
  - 依存関係管理

**理由:**
- 単一責任の原則: 各ガイドラインが1つの責務に集中
- テスト容易性: 登録と管理を独立してテスト可能
- 拡張性: 登録フローと管理フローを個別に拡張可能

**処理フロー:**
```
プランモード → プランファイル作成
         ↓
task-registration.md（参照） → タスクファイル作成
         ↓
task-manager-agent（参照） → タスク開始/完了/worktree管理
```

**注意**: エージェント定義（.md）は「処理ガイドライン」であり、メイン Claude Code が参照して直接ツールを実行する。Task tool で起動する「実行者」ではない。

---

### 禁止依存のコード上での検出

**判断**: 静的解析ツールによる自動検出は実装しない

**理由**:
- 個人開発では目視レビューで十分
- 静的解析ルールの設定コストが高い
- 違反時は EventSystem 経由に書き直すだけ

**代替策**:
- using / import 文で相互参照に気づきやすい
- コンパイルエラーにはならないが、循環参照は IDE が警告することが多い

---

## フレームワークのバージョニング

- 破壊的変更（番号体系変更など）: メジャーバージョンアップ（v2 → v3）
- 機能追加: マイナーバージョンアップ（v2.10 → v2.11）
- 既存プロジェクトへの影響がない変更: パッチ（v2.11.1）

---

## 次に読むべきドキュメント

- [フレームワーク仕様書](./framework-spec.md) - コア仕様全体
- [フレームワーク開発ガイド](../framework-development/guide.md) - フレームワーク自体の開発方法
- [開発の記録](../framework-development/philosophy.md) - なぜこのシステムを作っているのか
