# 仕様書駆動開発 ユーザーズガイド

Claude Code のサブエージェント機能を活用した開発フローの完全ガイド。

---
**対象読者**: 初めてフレームワークを使うゲーム開発者
**所要時間**: 20分
**前提知識**: 基本的なプログラミング知識
**次に読むべき**: [agent-selection-guide.md](./agent-selection-guide.md)（機能別）、[framework-spec.md](../reference/framework-spec.md)（詳細仕様）

---

> **📘 このドキュメントについて**
>
> これは**クイックスタート向け**のガイドです。
> 全体フローを素早く把握し、すぐに開発を始めたい方に最適です。
>
> - 詳しい概念説明や背景理論 → [完全リファレンス](./users-guide-reference.md)
> - 各エージェントの完全仕様 → [エージェント詳細リファレンス](./agent-details.md)

---

## 全体フロー概要

```
┌─────────────────────────────────────────────────────────────────┐
│  Phase 0: プロジェクト初期化                                      │
│  ─────────────────────────────────────────────────────────────  │
│  🔧 setup-agent  フォルダ構成・CLAUDE.md・GitHub設定             │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│  Phase 0.5: アーキテクチャ設計（推奨）                             │
│  ─────────────────────────────────────────────────────────────  │
│  🏛️ architecture-agent  イベントシステム・入力システム・レイヤー設計│
│  ※ 新規プロジェクトでは Phase 1 の前に実施を推奨                   │
│  ※ 小規模プロジェクトではスキップ可                               │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│  Phase 1: 要件策定（上流）                                        │
│  ─────────────────────────────────────────────────────────────  │
│  💬 requirements-agent  対話で深掘り                             │
│          ↓                                                      │
│  📋 spec-agent  文書化                                          │
│          ↓                                                      │
│  🔍 critic-agent  批評・検証 → 問題あれば上流に戻る               │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│  Phase 2: 詳細設計                                               │
│  ─────────────────────────────────────────────────────────────  │
│  🏗️ design-agent → ⚙️ behavior-agent → 🧪 test-agent           │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│  Phase 3: タスク管理 & 実装                                       │
│  ─────────────────────────────────────────────────────────────  │
│  📝 task-registration-agent → 🗂️ task-manager-agent → 💻 impl-agent │
│  (プラン→タスク)         (ライフサイクル管理)        (実装)       │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│  Phase 4: 検証・イテレーション                                    │
│  ─────────────────────────────────────────────────────────────  │
│  ✅ review-agent  整合性チェック → 仕様/実装の修正                │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  横断的サポート（随時使用）                                       │
│  ─────────────────────────────────────────────────────────────  │
│  🏛️ architecture-agent アーキテクチャ設計（Phase 0.5 または随時） │
│  🔗 deps-agent 依存関係   📊 data-agent マスタデータ              │
│  ♻️ refactor-agent 廃止・共有化                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## エージェント一覧（全17種）

### 仕様策定フェーズ（上流：要件を固める）

| アイコン | エージェント | 責務 | 入力 | 出力 |
|---------|-------------|------|------|------|
| 💬 | requirements-agent | 対話で要件を深掘り | アイデア | 要件サマリ |
| 📋 | spec-agent | EARS記法で文書化 | 要件サマリ | xxxxx_spec.md |
| 🔍 | critic-agent | 仕様の批評・検証 | spec.md等 | 批評レポート |

### 仕様策定フェーズ（下流：詳細設計）

| アイコン | エージェント | 責務 | 入力 | 出力 |
|---------|-------------|------|------|------|
| 🏗️ | design-agent | Component, 定数, Enum | spec.md | xxxxx_design.md |
| ⚙️ | behavior-agent | System, 状態遷移 | spec + design | xxxxx_behavior.md |
| 🧪 | test-agent | BDDテストシナリオ | spec + behavior | xxxxx_test.md |

> **用語の注意: 「System」の使い分け**
>
> 本ドキュメントでは「System」を以下の2つの意味で使用します：
> - **ECS の System**: 特定の Component を処理するロジック単位（例: `PlayerMovementSystem`）
> - **一般的なシステム**: アーキテクチャ全体を構成する仕組み（例: 「イベントシステム」「入力システム」）
>
> ECS の System を指す場合は `PascalCase` で記載し、一般的なシステムはカタカナ表記で区別しています。

### 実装・検証フェーズ

| アイコン | エージェント | 責務 | 入力 | 出力 |
|---------|-------------|------|------|------|
| 📝 | task-registration-agent | プランファイル→タスクファイル変換 | プランファイル | Markdownタスクファイル |
| 🗂️ | task-manager-agent | タスクライフサイクル管理, worktree連携 | タスクファイル | 状態遷移, worktree |
| 💻 | impl-agent | コード実装 | 全仕様書 | コード（@spec付き） |
| ✅ | review-agent | 整合性検証 | 全仕様書 | レポート |

### 横断的エージェント

| アイコン | エージェント | 責務 | 入力 | 出力 |
|---------|-------------|------|------|------|
| 🔧 | setup-agent | プロジェクト初期化 | 要件 | フォルダ構成 |
| 🏛️ | architecture-agent | アーキテクチャ設計 | concept.md, 要件 | 2_architecture/*.md |
| 🔗 | deps-agent | 依存関係管理 | 仕様書群 | dependencies.md |
| ♻️ | refactor-agent | 廃止, 共有化 | 仕様書群 | 移行後の仕様書 |
| 📊 | data-agent | マスタテーブル管理 | 仕様書 | 8_data/*.md |

### 参照資料管理エージェント

| アイコン | エージェント | 責務 | 入力 | 出力 |
|---------|-------------|------|------|------|
| 🔬 | legacy-analyzer-agent | レガシーコード解析 | C++コード | 9_reference/901_*/*.md |
| 🎮 | game-reference-agent | 参照ゲーム仕様観察 | 画像/説明/Web | 9_reference/901_*/*.md |

**注**: 各エージェントの詳細な仕様・制約事項・高度な使用方法については [エージェント詳細リファレンス](./agent-details.md) を参照してください。

---

## Phase 0: プロジェクト初期化

### setup-agent の使用

```
「新規プロジェクトを初期化して」
「セットアップして」
```

### 確認される項目

- プロジェクト名
- ゲームジャンル
- 使用エンジン（Unity / Godot）
- 最初に実装する機能

### 生成される構成（ミニマム）

```
docs/
├── 1_project/
│   └── 10001_concept.md
└── 3_ingame/
    └── 301_player/
        ├── 30101_player_spec.md
        └── 30102_player_design.md

.claude/
├── agents/          # 全エージェント
├── commands/        # スラッシュコマンド
└── skills/
    └── ears.md      # EARS記法ガイド

CLAUDE.md
.claudeignore
.github/ISSUE_TEMPLATE/
```

---

## Phase 1: 要件策定（上流）

### 1-1. 💬 requirements-agent（要件の深掘り）

```
「ジャンプ機能について相談したい」
「この機能のエッジケースを詰めたい」
「要件を固めたい」
```

**対話例:**
```
エージェント: 「ジャンプ中に攻撃ボタンを押したらどうなりますか？」
あなた: 「空中攻撃になる」
エージェント: 「空中攻撃中にさらにジャンプ入力があったら？」
あなた: 「無視する」
エージェント: 「着地直前にジャンプを押していた場合は？」
あなた: 「バッファして着地後にジャンプ」
```

**出力:** 要件サマリ（対話結果のまとめ）

### 1-2. 📋 spec-agent（文書化）

```
「要件をspec.mdに文書化して」
「EARS記法で書いて」
```

**入力:** 💬 requirements-agent の要件サマリ
**出力:** xxxxx_spec.md

### 1-3. 🔍 critic-agent（批評・検証）

```
「この仕様を批評して」
「矛盾や漏れがないかチェックして」
```

**出力例:**
```markdown
## 🔴 致命的な問題
### 問題: 同時入力時の優先順位が未定義
**箇所**: REQ-30101-002, REQ-30101-003
**改善案**: 優先順位を明示的に定義する

## 🟡 重要な指摘
### 指摘: 「すぐに」の定義が曖昧
**箇所**: REQ-30101-005
**改善案**: 「同フレーム内に」等、具体的に記述
```

**問題があれば** → 💬 requirements-agent に戻って修正

---

## Phase 2: 詳細設計

### 2-1. design-agent（データ構造）

```
「Player の Component を設計して」
「データ構造を定義して」
```

### 2-2. behavior-agent（ロジック）

```
「Player の移動ロジックを設計して」
「状態遷移を定義して」
```

### 2-3. test-agent（テストシナリオ）

```
「Player のテストシナリオを作成して」
「Given/When/Then で書いて」
```

---

## Phase 3: タスク管理 & 実装

### タスク管理の概要

このフレームワークでは、タスクを **Markdownファイル** で管理します。

**なぜMarkdownベースなのか:**
- ✅ **Claude Code が直接操作できる** - Read/Write/Edit ツールで自律管理
- ✅ **Git で完全にバージョン管理** - タスクの変更履歴がコミット履歴として残る
- ✅ **worktree統合** - 複数ターミナルで並列開発が可能
- ✅ **検索・grep が容易** - IDE検索で全タスクを横断検索
- ✅ **外部ツール不要** - GitHub Issues等のアカウント不要

#### タスク作成の2段階フロー（IMPORTANT）

**タスク作成は「プラン作成」と「タスク登録」の2段階に分離されています。**

**フロー（2段階）:**
```
【ステップ1: プラン作成】
人間: 「プレイヤーのジャンプ機能を実装したい」
↓
メイン Claude Code: プランモードに入り調査・計画
↓
プランファイル保存（~/.claude/plans/xxx.md）

【ステップ2: タスク登録】
人間: 「プランからタスクを作成して」
↓
メイン Claude Code: task-registration-agent.md を参照して直接実行
  1. プランファイル検出
  2. プランファイル読み込み
  3. タスクタイプ判定
  4. ID採番（/id-next）
  5. タスクファイル作成
↓
タスクファイル生成（tasks/1_todo/ または project/tasks/1_todo/）
```

**責務分離:**
- **task-registration-agent**: プランファイル → タスクファイル変換専門
- **task-manager-agent**: タスクライフサイクル管理専門（開始/完了/worktree）

**注意**: エージェント定義（.md）は「処理ガイドライン」であり、メイン Claude Code が参照して直接ツールを実行します。

**3つのタスクタイプ:**

| タスク種別 | ID形式 | 配置 | worktree | 用途 |
|-----------|-------|------|---------|------|
| ゲーム開発 | `30XXX` | `project/tasks/` | ✅ | `project/` 配下の仕様書・実装 |
| プロジェクト横断 | `PXXX` | `project/tasks/` | ❌ | CI/CD、インフラ設定 |
| フレームワーク | `FXXX` | `tasks/` | ❌ | エージェント、ドキュメント更新 |

**worktree統合の利点:**
- 各タスクが独立したワーキングディレクトリ（ブランチ）を持つ
- ブランチ切り替え不要、並列作業が可能
- 例: ターミナル1でプレイヤー実装、ターミナル2で敵実装を同時進行

**📖 詳細ガイド:**
タスク管理の詳細は [タスク管理ガイド](./task-management-guide.md)（30分）を参照してください。
このセクションでは基本的なワークフローのみを説明します。

### クイックスタート: 単一機能実装

**目標**: プレイヤーのジャンプ機能を実装する

#### 1. タスク作成（2段階フロー）

**ステップ1: プラン作成**
```
人間: 「プレイヤーのジャンプ機能を実装したい」

メイン Claude Code の動作:
1. プランモードに移行
2. 関連調査:
   - project/docs/3_ingame/30100_player/spec.md 確認
3. ユーザー確認:
   「ジャンプの入力はSpaceキーで良いですか？」
4. プランファイル作成:
   ~/.claude/plans/task-jump.md
5. プランモード終了
```

**ステップ2: タスク登録**
```
人間: 「プランからタスクを作成して」

メイン Claude Code の動作（task-registration-agent.md を参照）:
1. プランファイル検出（Bash: ls ~/.claude/plans/）
2. プランファイル読み込み（Read）
3. タスクタイプ判定（game-dev）
4. ID採番（/id-next → 30101）
5. タスクファイル作成（Write）:
   project/tasks/1_todo/30101-ジャンプ機能実装.md
   （プランファイルの全内容を埋め込み）
```

**確認:**
タスクファイルが `project/tasks/1_todo/30101-ジャンプ機能実装.md` に作成されていることを確認します。

#### 2. タスク開始

**人間の指示:**
```
タスク30101を開始して
```

**メイン Claude Code の動作（task-manager-agent.md を参照）:**
```
→ status: todo → in-progress
→ worktree作成: ../spec-driven-framework-jump
→ ファイル移動: 1_todo/ → 2_in-progress/
```

#### 3. 実装

**人間の指示:**
```
プレイヤーのジャンプ機能を実装して
```

**impl-agent の動作:**
```
→ タスクファイルの Detailed Implementation Plan を参照
→ 仕様書に基づいて実装
```

#### 4. タスク完了

**人間の指示:**
```
タスク30101を完了にして
```

**メイン Claude Code の動作（task-manager-agent.md を参照）:**
```
→ status: in-review → done
→ ファイル移動: 3_in-review/ → 4_archive/
```

### クイックスタート: 並列開発

**目標**: プレイヤー、敵、ステージを並列実装する

```
準備: 3つのタスクを作成
「以下の3つのタスクを作成して：
- プレイヤー実装（30101）
- 敵実装（30201）
- ステージ1実装（30301）」

並列実行:
Terminal 1: 「タスク30101を開始して」
  → worktree: ../spec-driven-framework-player
  → 実装作業

Terminal 2: 「タスク30201を開始して」
  → worktree: ../spec-driven-framework-enemy
  → 実装作業

Terminal 3: 「タスク30301を開始して」
  → worktree: ../spec-driven-framework-stage
  → 実装作業

マージ:
各ターミナルで実装が完了したら、順次PRをマージ
```


---

### 3-1. タスク登録とタスク管理（責務分離）

**責務分離:**
- **task-registration-agent**: プランファイル → タスクファイル変換
- **task-manager-agent**: タスクライフサイクル管理（開始/完了/worktree）

**タスク登録（task-registration-agent.md を参照）:**
```
「プランからタスクを作成して」

メイン Claude Code の動作:
1. プランファイル検出（~/.claude/plans/）
2. タスクタイプ判定
3. ID採番（/id-next）
4. タスクファイル作成（Write）
```

**タスク管理（task-manager-agent.md を参照）:**
```
「タスク30101を開始して」

メイン Claude Code の動作:
→ status: todo → in-progress
→ worktree作成（game-devタスクのみ）
→ ファイル移動: 1_todo/ → 2_in-progress/
```

**タスクファイル構造:**
```markdown
---
id: "30101"
type: game-dev
title: ジャンプ機能実装
status: todo
priority: high
tags: [feat, player]
plan_file: "/Users/xxx/.claude/plans/task-jump.md"
---

# Task 30101: ジャンプ機能実装

## 説明
...

## Detailed Implementation Plan
（プランファイルの全内容が埋め込まれる）
```

### 3-2. impl-agent（実装）

```
「Player のジャンプ機能を実装して」
「仕様書に従ってコードを書いて」
```

**実装ルール:**
- 仕様書にない機能は実装しない
- `@spec` `@test` `@data` コメントを付与
- コミットメッセージ形式を遵守

**出力例:**
```csharp
// @spec REQ-30101-001
// @spec REQ-30101-002
public class PlayerJumpSystem : ISystem
{
    public void Execute()
    {
        // 仕様書 behavior.md に従った実装
    }
}
```

---

### 3-3. Progress/Next Actions管理

**タスクの進捗と次のアクションを明示的に記録します。**

#### なぜ必要か

- 📊 **進捗の可視化**: タスクファイルを見るだけで、今までに何をしたか分かる
- 🔄 **セッション引き継ぎ**: 別セッションで作業を再開する際、状況を即座に把握
- 📝 **次のアクション明確化**: 作業完了後、何をすべきか迷わない
- 🤖 **エージェント自動化**: impl-agent/review-agent が自動記録

#### Progress記録（進捗履歴）

**記録タイミング:**
- 重要なマイルストーン達成時（Phase完了、実装完了等）
- コミット実行後（impl-agent が自動記録）
- レビュー完了後（review-agent が自動記録）

**記録方法:**
- Claude Code がタスクファイルの `## Progress` セクションを直接編集

**タスクファイル内の表現:**
```markdown
## Progress

- 2025-01-30 14:00: ジャンプ機能実装完了、コミット abc1234
- 2025-01-30 15:30: レビュー完了: ID重複1件検出
- 2025-01-30 16:00: ID重複修正、再コミット def5678
```

#### Next Actions更新（次のアクション）

**更新タイミング:**
- 作業完了後、次のステップが明確な場合
- レビューで問題検出時（修正タスクリスト）
- ブロック解消時

**更新方法:**
- Claude Code がタスクファイルの `## Next Actions` セクションを直接編集

**タスクファイル内の表現:**
```markdown
## Next Actions

- [ ] review-agentでレビュー実施
- [ ] テストコード追加
```

#### エージェント自動化

**impl-agent（コミット後）:**
- Progress に「実装完了: <コミットサマリ>」を自動追記
- Next Actions を「レビュー実施」に自動更新

**review-agent（レビュー後）:**
- Progress に「レビュー完了: <結果サマリ>」を自動追記
- Next Actions を修正タスクリストまたは完了準備に自動更新

#### セッション再開時の確認

`/resume-handover` コマンドでタスクの状態を素早く把握できます。

**表示内容:**
- Task ID と Title、現在の status
- 直近の Progress 履歴
- 次実行すべき Next Actions

#### 典型的なワークフロー

```
1. タスク作成
   「ジャンプ機能のタスクを作成して」
   ↓
2. 実装・コミット
   「ジャンプ機能を実装して」
   → impl-agent が実装・コミット
   → 自動: add-progress "実装完了"
   → 自動: update-next-actions "レビュー実施"
   ↓
3. レビュー
   「タスク30101をレビューして」
   → review-agent が検証
   → 自動: add-progress "レビュー完了: 問題なし"
   → 自動: update-next-actions "タスク完了"
   ↓
4. タスク完了
   「タスク30101を完了にして」
```

**📖 詳細:** [タスクワークフロー](../../.claude/skills/task-workflow.md#progress-と-next-actions-の管理)

---

## Phase 4: 検証・イテレーション

### review-agent（整合性検証）

```
「仕様書の整合性をチェックして」
「/docs-validate を実行して」
```

**検証項目:**
- ID 重複チェック（REQ/DES/BHV/TST）
- 参照整合性（TST → REQ の存在確認）
- 未テスト要件の検出
- 禁止依存の検出
- リンク切れチェック

**出力例:**
```
=== Review Report ===

[PASS] REQ-ID 重複チェック
[PASS] TST-ID 重複チェック
[FAIL] TST-30105-003 が参照する REQ-30101-005 が存在しません
[WARN] REQ-30101-003 に対応する TST が存在しません

=== Summary ===
PASS: 10, FAIL: 1, WARN: 1
```

---

## 横断的エージェントの使用

### 🔗 deps-agent（依存関係管理）

```
「依存関係を確認して」
「dependencies.md を更新して」
```

### 📊 data-agent（マスタデータ管理）

```
「敵のパラメータテーブルを作成して」
「balance 調整して」
```

### ♻️ refactor-agent（リファクタリング・廃止）

```
「古い機能を廃止して」
「HealthComponent を共有化して」
```

---

## 開発パターン別フロー

### パターン A: 新機能を最初から作る

```
1. 🗂️ task-manager-agent → タスク作成（必須：最初のステップ）
2. 💬 requirements-agent → 対話で要件を固める
3. 📋 spec-agent         → 文書化
4. 🔍 critic-agent       → 批評（問題あれば2に戻る）
5. 🏗️ design-agent       → データ構造
6. ⚙️ behavior-agent     → ロジック
7. 🧪 test-agent         → テストシナリオ
8. 💻 impl-agent         → 実装
9. ✅ review-agent       → 検証
```

**重要:** タスク作成は最初のステップです。worktree/ブランチが自動作成されるため、並列作業時の競合を回避できます。

### パターン B: バグを修正する

```
1. 🗂️ task-manager-agent → バグ修正タスク作成（必須）
2. ✅ review-agent       → 原因特定
3. 💬 requirements-agent → 修正内容を深掘り（必要なら）
4. 📋 spec-agent         → 仕様に問題があれば修正
5. 💻 impl-agent         → 実装修正
6. ✅ review-agent       → 再検証
```

**重要:** バグ修正も必ずタスクを作成します。修正履歴を追跡可能にするためです。

### パターン C: 仕様変更に対応する

```
1. 🗂️ task-manager-agent → 仕様変更タスク作成（必須）
2. 💬 requirements-agent → 変更内容を深掘り
3. 📋 spec-agent         → 既存 spec.md を更新
4. 🔍 critic-agent       → 影響範囲を批評
5. 🏗️ design-agent       → 影響があれば design.md を更新
6. ⚙️ behavior-agent     → 影響があれば behavior.md を更新
7. 🧪 test-agent         → テストシナリオを更新
8. ✅ review-agent       → 整合性確認
9. 💻 impl-agent         → 実装修正
```

**重要:** 仕様変更も必ずタスクを作成します。変更の影響範囲を管理するためです。

### パターン D: 機能を廃止する

```
1. 🔗 deps-agent         → 参照元を特定
2. ♻️ refactor-agent     → 廃止実行
3. ✅ review-agent       → 整合性確認
```

### パターン E: 要件が既に明確な場合（スキップ可）

```
1. 📋 spec-agent         → 直接文書化
2. 🔍 critic-agent       → 念のため批評
3. 以降通常フロー
```

---

## 自動ルーティングのキーワード

Claude Code はタスク内容からエージェントを自動選択します。
以下のキーワードで明示的に誘導できます：

| キーワード | 選択されるエージェント |
|-----------|----------------------|
| 「初期化」「セットアップ」「新規プロジェクト」 | 🔧 setup-agent |
| 「相談」「深掘り」「詰めたい」「固めたい」 | 💬 requirements-agent |
| 「文書化」「EARS」「REQ」「spec.mdを作成」 | 📋 spec-agent |
| 「批評」「矛盾」「漏れ」「問題点を指摘」 | 🔍 critic-agent |
| 「Component」「フィールド」「データ構造」 | 🏗️ design-agent |
| 「System」「状態遷移」「ロジック」「振る舞い」 | ⚙️ behavior-agent |
| 「テスト」「Given/When/Then」「TST」 | 🧪 test-agent |
| 「実装」「コードを書いて」「@spec」 | 💻 impl-agent |
| 「検証」「整合性」「validate」 | ✅ review-agent |
| 「依存」「deps」「参照関係」 | 🔗 deps-agent |
| 「プランからタスクを作成」「タスク登録」 | 📝 task-registration-agent |
| 「タスク開始」「タスク完了」「worktree」 | 🗂️ task-manager-agent |
| 「廃止」「共有化」「リファクタ」「移動」 | ♻️ refactor-agent |
| 「テーブル」「マスタデータ」「balance」「8_data」 | 📊 data-agent |

### 💬 requirements-agent vs 📋 spec-agent

| 状況 | 使うエージェント |
|------|-----------------|
| アイデアがぼんやりしている | 💬 requirements-agent |
| エッジケースを詰めたい | 💬 requirements-agent |
| 要件が既に固まっている | 📋 spec-agent |

### 🔍 critic-agent vs ✅ review-agent

| 状況 | 使うエージェント |
|------|-----------------|
| 仕様の内容を批評してほしい | 🔍 critic-agent |
| ID重複やリンク切れをチェック | ✅ review-agent |

---

## コマンドチートシート

```bash
# ID 管理
/id REQ-30101-001          # 定義箇所を表示
/id-list 30101             # ファイル内の全IDを一覧
/id-refs REQ-30101-001     # 参照箇所を検索
/id-next REQ-30101         # 次の連番を取得

# ドキュメント管理
/docs-validate             # 整合性チェック

# 依存関係
/deps-check                # 禁止依存・リンク切れ検出
/deps-graph                # Mermaid 図を再生成

# Component 管理
/component-share HealthComponent 30102
```

---

## Tips

### 仕様書の完成度と実装開始の判断

| 完成している仕様書 | 実装可否 |
|-------------------|---------|
| spec のみ | ✗ 実装不可 |
| spec + design | △ プロトタイプ可 |
| spec + design + behavior | ◯ 本実装可 |
| 全部（test 含む） | ◎ TDD 可 |

### エージェントへの指示のコツ

1. **対象を明確に**: 「Player の」「Enemy の」
2. **ファイル番号を含める**: 「30101 の spec を」
3. **出力形式を指定**: 「Markdown で」「テーブル形式で」

### 困ったときは

- 整合性エラー → `review-agent` で原因特定
- 依存関係の問題 → `deps-agent` で可視化
- どのエージェントか迷う → タスクをそのまま伝える（自動ルーティング）
