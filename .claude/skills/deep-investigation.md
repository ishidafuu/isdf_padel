# 技術質問への詳細回答（Deep Investigation）

ユーザーの技術的な質問に対して、コードベースを深く調査し、熟練プログラマーが満足する詳細で正確な回答を提供するスキル。

## 参照元ガイドライン

- 🏛️ architecture-agent.md - アーキテクチャ調査時
- 💻 impl-agent.md - 実装前の既存コード理解時
- 📊 data-agent.md - データ構造調査時

**使用タイミング**: 複雑な技術質問や、既存コードの深い理解が必要な場合

---

## 基本原則

### コード編集禁止

- **原則**: ユーザーが明示的に指示しない限り、コードの編集・修正は行いません
- **目的**: 質問への回答であり、実装ではない
- **例外**: ユーザーが「実装して」「修正して」と明示した場合のみ

### 事実ベースの回答

- **推測の禁止**: 「おそらく」「だと思われます」は使わない
- **根拠の明示**: すべての回答に具体的なファイルパス・行番号を付ける
- **不明の明記**: わからないことは「不明」と明確に記録

### 拡張思考

複雑な調査では以下を深く考慮する：

- **本質的な原因**: 表面的な現象ではなく、根本原因を探る
- **システム間の相互作用**: 単一コンポーネントではなく、システム全体を俯瞰
- **エッジケース**: 通常のケースだけでなく、特殊な状況も考慮
- **ベストプラクティス**: 現在の実装と業界標準の比較

---

## ワークフロー

### フェーズ 0: タスク管理の準備

**必須**: 以下のフェーズを TodoWrite でタスク化する

```
例:
- [ ] 初期セットアップとコードベース分析
- [ ] コンテキスト発見質問（必要に応じて）
- [ ] ターゲット指向のコンテキスト収集
- [ ] ユーザーへの回答作成
```

### フェーズ 1: 初期セットアップとコードベース分析

質問に直接関連する情報を取得：

**1.1 明示的な情報の収集**
```
- 質問に明記されているクラス/ファイル/関数
- エラーメッセージやスタックトレース
- ユーザーが提供したコードスニペット
```

**1.2 プロジェクト全体構造の把握**
```
- ドキュメント（README, ARCHITECTURE等）の確認
- 技術スタック（package.json, requirements.txt等）
- 主要コンポーネントとディレクトリ構造
- コーディング規約とパターン
```

**1.3 関連クラス/機能の推測**
```
質問: 「ゲームのセーブ機能はどう実装されていますか？」
↓
推測される関連クラス:
- SaveManager, SaveData
- GameState, PlayerData
- FileSystem, LocalStorage
```

### フェーズ 2: コンテキスト発見質問

**省略条件**（以下のいずれかに該当する場合はスキップ）:
- 質問が特定のファイル/クラスを明示している
- バグレポートで再現手順が明確
- ユーザーが既に十分なコンテキストを提供している
- 質問が自明（「このファイルは何をしていますか？」等）

**実行する場合**:
問題空間を理解するための最も重要な3-5個のyes/no質問を生成：

```
質問例:
1. このエラーは特定の操作で常に発生しますか？
   → [はい] [いいえ] [わからない]

2. 最近コードベースに大きな変更がありましたか？
   → [はい（詳細: ___）] [いいえ] [不明]

3. 本番環境と開発環境の両方で発生しますか？
   → [両方] [本番のみ] [開発のみ] [未確認]
```

**重要**: スマートデフォルトオプションを提案しながら、まとめて質問する

### フェーズ 3: ターゲット指向のコンテキスト収集

**調査手法の詳細は「## 調査方法」セクションを参照**

すべての発見質問が回答された後：

**3.1 調査タスクの洗い出し**
```
TodoWrite でタスク化:
- [ ] SaveManager クラスの詳細調査
- [ ] セーブデータフォーマットの確認
- [ ] エラーハンドリング実装の調査
- [ ] 類似機能（LoadManager）の参照
- [ ] Git履歴から変更点を追跡
```

**3.2 波状調査の実行**
- **第1波**: Critical（必須）タスクを SubAgent で並列実行（最大3個）
- **第2波**: Important（重要）タスクを SubAgent で並列実行（最大2-3個）
- **第3波**: Nice-to-have（補足）タスクを親エージェントが直接実行

**3.3 調査内容**
- 発見回答に基づいた特定のファイルを検索
- 関連コードをバッチ読み込み
- 類似機能とパターンを深く調査
- 具体的な実装詳細を分析
- エラーログやスタックトレースを分析
- 関連するコードパスを追跡
- 類似の問題や既知の制限事項を調査
- 現在の実装パターンを分析
- 他の部分での類似実装を参照
- ベストプラクティスとの比較
- ベストプラクティスやライブラリドキュメントのために WebSearch やライブラリのソースコードを調査
- 問題が発生し原因を理解するために関連するファイルの Git 変更履歴を探索

### フェーズ 4: ユーザーへの回答

収集したコンテキストに基づき、以下のフォーマットで回答：

#### 回答フォーマット

```markdown
## 質問の要約
[ユーザーの質問を簡潔に再確認]

## 回答（結論）
[1-2段落で結論を先に提示]

## 詳細な説明

### 実装の場所
- `src/core/SaveManager.ts:45-120` - メインのセーブロジック
- `src/types/SaveData.ts:10-35` - データ構造定義
- `src/utils/FileSystem.ts:78` - ファイル書き込み処理

### アーキテクチャ
[必要に応じて図やフロー]

### 具体的なコード例
```typescript
// 実際のコードスニペット（行番号付き）
```

### 動作の流れ
1. [ステップ1]
2. [ステップ2]
3. [ステップ3]

## 根拠
- [調査で発見した事実1]
- [調査で発見した事実2]
- [Git履歴で確認した変更]

## 関連リソース
- `docs/architecture.md` - 関連する設計ドキュメント
- [外部リンク] - ライブラリの公式ドキュメント

## 補足・注意点
[あれば記載]
```

---

## 調査方法

### 並列調査の基本戦略

**目的**: 調査時間を削減し、効率的にコンテキストを収集する

**原則**:
1. TodoWrite で調査タスクを全て可視化
2. 波状実行で段階的に調査（3個 → 2-3個 → 親）
3. 各波の結果を統合してから次の波へ
4. コンテキストが十分になったら調査を終了

### 波状調査の詳細

#### 第1波: Critical タスク（最大3個の SubAgent）

**対象**: 質問に答えるために**絶対に必要**な情報

```
質問: 「ゲームのセーブ機能はどう実装されていますか？」

第1波（3個並列）:
├ SubAgent 1: SaveManager クラスの詳細調査
├ SubAgent 2: セーブデータフォーマットとシリアライゼーション
└ SubAgent 3: セーブ/ロードのエラーハンドリング
```

**並列実行の例**:

> **注記**: 以下のXML形式はTask toolの呼び出しイメージです。実際には、メイン Claude Code がTask toolを使って同様の並列調査を実行します。

```xml
<function_calls>
<invoke name="Task">
  <parameter name="subagent_type">general-purpose</parameter>
  <parameter name="description">SaveManager クラス詳細調査</parameter>
  <parameter name="prompt">
ユーザーの質問: 「ゲームのセーブ機能はどう実装されていますか？」

現在の理解:
- SaveManager.ts が存在する可能性（未確認）
- JSON形式でlocalStorageに保存している可能性（推測）

調査目標:
1. SaveManager クラスの正確な場所を特定
2. クラスのメソッド構成（save, load等）を詳細に調査
3. 依存しているクラス/ライブラリを特定
4. 使用方法の例を探す

調査方法:
1. Glob で "**/SaveManager*" を検索
2. 見つかったファイルを Read
3. import文から依存関係を追跡
4. Grep で使用例を検索

期待する出力:
- ファイルパス:行番号
- メソッドシグネチャ（引数、戻り値）
- 依存関係リスト
- 使用例のコードスニペット
- 不明だった点
  </parameter>
</invoke>
<invoke name="Task">
  <parameter name="subagent_type">general-purpose</parameter>
  <parameter name="description">セーブデータフォーマット調査</parameter>
  <parameter name="prompt">
ユーザーの質問: 「ゲームのセーブ機能はどう実装されていますか？」

現在の理解:
- セーブデータの形式が不明
- JSONの可能性が高いが未確認

調査目標:
1. セーブデータの形式（JSON, Binary, etc）
2. データ構造の詳細
3. シリアライゼーション/デシリアライゼーションの実装
4. バージョン管理やマイグレーション戦略

調査方法:
1. Grep で "serialize|stringify|parse" を検索
2. SaveData, GameState等の型定義を探す
3. 実際のシリアライゼーション処理を Read
4. テストファイルでデータ例を確認

期待する出力:
- データ形式
- 型定義（ファイルパス:行番号）
- シリアライゼーション実装の詳細
- データ例
- 不明だった点
  </parameter>
</invoke>
<invoke name="Task">
  <parameter name="subagent_type">general-purpose</parameter>
  <parameter name="description">エラーハンドリング調査</parameter>
  <parameter name="prompt">
ユーザーの質問: 「ゲームのセーブ機能はどう実装されていますか？」

現在の理解:
- エラー処理の実装が不明
- GameError例外の可能性（推測）

調査目標:
1. セーブ失敗時のエラーハンドリング
2. エラーの種類とメッセージ
3. リトライロジックの有無
4. ユーザーへのエラー通知方法

調査方法:
1. SaveManager内のtry-catch, throw を検索
2. エラー型定義を探す
3. エラー処理の実装を Read
4. UIへのエラー表示ロジックを追跡

期待する出力:
- エラーハンドリングの実装（ファイルパス:行番号）
- エラーの種類一覧
- リトライロジックの詳細
- UI通知の仕組み
- 不明だった点
  </parameter>
</invoke>
</function_calls>
```

**第1波完了後**:
```
結果の統合:
├ 70%以上の情報が得られた → 第2波へ
├ 30-70%の情報 → 戦略を見直してから第2波
└ 30%未満 → ユーザーに中間報告、方向性を確認
```

#### 第2波: Important タスク（最大2-3個の SubAgent）

**対象**: 回答の質を高めるために**重要**な情報

```
第1波の結果を踏まえて:
├ SubAgent 4: 自動セーブ機能の実装
├ SubAgent 5: セーブデータのマイグレーション戦略
└ SubAgent 6: パフォーマンス最適化の実装
```

**実行条件**:
- 第1波で基本的な質問への回答は可能になっている
- より詳細な情報が必要と判断された場合のみ

#### 第3波: Nice-to-have タスク（親エージェントが直接実行）

**対象**: 補足的な情報

```
親エージェントが直接:
├ ベストプラクティスとの比較（WebSearch）
├ 関連ドキュメントの確認
└ テストコードの参照
```

**実行条件**:
- 既存コンテキストで十分調査可能
- SubAgent を起動するほどではない

### SubAgent への指示方法

**必須項目**:
1. ユーザーの元の質問
2. 現在の理解（既知の情報）
3. 調査目標（明確に）
4. 調査方法（具体的な手順）
5. 期待する出力形式

**良い例**:
```
ユーザーの質問: [元の質問]

現在の理解:
- [確定している事実]
- [推測（要確認）]

調査目標:
1. [具体的な目標1]
2. [具体的な目標2]

調査方法:
1. Glob で "pattern" を検索
2. 見つかったファイルを Read
3. Grep で関連コードを探す

期待する出力:
- ファイルパス:行番号
- クラス/関数のシグネチャ
- 依存関係
- コード例
- 不明だった点（明記）
```

**悪い例**:
```
SaveManager について調べてください。
```
（コンテキスト不足、目標不明確、期待する出力が不明）

### SubAgent からの報告形式

SubAgent は以下を含めて報告：

```markdown
## 調査結果

### 判明した事実
- **ファイルの場所**: `src/core/SaveManager.ts`
- **クラス構成**:
  ```typescript
  class SaveManager {
    save(data: SaveData): Promise<void>
    load(): Promise<SaveData>
    delete(): Promise<void>
  }
  ```
- **依存関係**:
  - `src/types/SaveData.ts` - データ型定義
  - `localStorage` - Web Storage API
- **使用例**: `src/game/GameController.ts:156`

### 不明だった点
- セーブデータのバージョン管理戦略（コードに記載なし）
- 複数セーブスロットのサポート（未実装の可能性）

### さらなる調査の必要性
- [ ] GameController での SaveManager の使用方法を詳細に調査
- [ ] localStorage以外のストレージオプション（IndexedDB等）の検討履歴
```

---

## エラーハンドリング

### SubAgent 結果の品質チェック

各 SubAgent 完了後、以下を確認：

#### ✅ 良い結果の条件

- [ ] 具体的なファイルパス・行番号が含まれる
- [ ] クラス/関数のシグネチャが明記されている
- [ ] 依存関係が図示または列挙されている
- [ ] コード例が具体的
- [ ] 「不明」な点が明確に区別されている
- [ ] 推測と事実が区別されている

#### ❌ 不十分な結果の例

- 「おそらく〜だと思われます」（推測）
- 「いくつかのファイルで〜」（具体性なし）
- 「調査しましたが見つかりませんでした」（調査方法が不明）
- ファイルパスや行番号がない
- 「〜あたりにあります」（曖昧）

### 不十分な結果への対処

#### 1. スコープ調整

調査範囲を狭める：

```
変更前: 「セーブ機能全体を調査」
変更後: 「SaveManager.save() メソッドの実装を調査」
```

#### 2. コンテキスト追加

より多くの情報を提供：

```diff
+ 既知の情報:
+ - SaveManager は src/core/save/SaveManager.ts に存在
+ - JSON形式でlocalStorageに保存している（確認済）
+ - エラー時は GameError 例外をスロー（推測）
+
+ 不明な点:
+ - セーブ失敗時のリトライロジック
+ - データ検証の実装
```

#### 3. 調査方法の明確化

具体的な手順を指示：

```
調査手順:
1. SaveManager.ts を Read（全体）
2. save() メソッドの実装を確認
3. 呼び出している他のメソッドを追跡
4. Grep で "SaveManager" を検索し、使用例を探す
5. テストファイルで期待される動作を確認
```

### 情報不足時のエスカレーション戦略

#### レベル1: 検索語の変更

```bash
# 失敗例
Grep: pattern="SaveManager" → 0 results

# 再試行
Grep: pattern="save.*game|persist.*state" -i → 15 results
Grep: pattern="class.*Save|interface.*Save" → 8 results
```

#### レベル2: 関連機能から類推

直接の実装が見つからない場合：

1. 類似機能を探す（例: LoadManager, ConfigManager）
2. その実装パターンを参考にする
3. 推測であることを明記して報告

```markdown
## 調査結果

SaveManager の直接的な実装は見つかりませんでしたが、
ConfigManager の実装パターンから以下が推測されます：

- **推測**: LocalStorage を使用している可能性
- **根拠**: ConfigManager が同様のパターンを使用（src/core/ConfigManager.ts:23）
- **確度**: ★★☆☆☆（類推）
```

#### レベル3: Git 履歴の調査

削除や移動の可能性を調査：

```bash
# 削除された可能性
git log --all --full-history -- "**/SaveManager*"

# 関連するコミットメッセージ
git log --grep="save" --grep="persist" -i --oneline

# ファイル名変更の追跡
git log --follow --all -- "**/*save*"
```

#### レベル4: 外部リソース調査

```
1. WebSearch: 使用しているフレームワークのドキュメント
2. WebFetch: ライブラリの公式ガイド
3. GitHub Issues: 既知の問題や議論
4. Stack Overflow: 類似の実装例
```

#### レベル5: 明確に「不明」と報告

調査を尽くしても見つからない場合：

```markdown
## 調査結果

### 判明した事実
- [具体的な発見内容]

### 不明な点（調査を尽くしたが特定できず）

#### SaveManager の実装場所
- **検索パターン**:
  - "SaveManager", "save.*manager", "**/save/**"
  - "persist", "storage", "serialize"
- **調査範囲**:
  - src/, lib/, core/ 配下全て
  - node_modules/ 内の主要ライブラリ
- **Git履歴**:
  - 削除履歴なし
  - リネーム履歴なし
- **結論**: 現在のコードベースには存在しない可能性が高い

### 推奨される次のアクション
1. ユーザーに実装場所のヒントを求める
2. または、セーブ機能の実装を新規で計画する
3. 別のアプローチ（ConfigManager等）が実際のセーブ処理を担っている可能性を調査
```

### 調査が深みにハマった場合

#### タイムボックス設定

- **各 SubAgent**: 最大3回までの再試行
- **調査全体**: 適切な範囲で判断（過度に長引かない）
- **再試行で解決しない場合**: 戦略変更またはユーザーに報告

#### 進捗チェックポイント

```
第1波完了時:
├ 70%以上の情報 → 第2波へ進む
├ 30-70%の情報 → 戦略を見直してから第2波
└ 30%未満 → ユーザーに中間報告

第2波完了時:
├ 十分な情報 → 回答作成へ
├ やや不足 → 親が直接追加調査
└ 大幅に不足 → ユーザーに状況報告
```

#### エスケープハッチ（中間報告）

調査が行き詰まった場合の報告テンプレート：

```markdown
## 中間報告

調査が予想以上に複雑になっています。現状を共有します。

### これまでの調査
- **試した検索パターン**:
  - "SaveManager", "save.*", "**/save/**"
- **読んだファイル**:
  - src/core/*.ts（全15ファイル）
  - src/game/GameController.ts
- **起動した SubAgent**: 3個（第1波完了）

### 判明したこと
- ✅ セーブ機能は ConfigManager が兼任している
- ✅ データ形式は JSON（localStorage 使用）
- ⚠️ エラーハンドリングが未実装（バグの可能性）

### まだ不明な点
- セーブデータのバージョン管理
- マルチスロット対応の有無
- セーブ失敗時のリトライロジック

### 次の選択肢

1. **現状の情報で回答を提供**（推奨）
   - 基本的な質問には答えられる
   - 不明点は「今後の調査事項」として明記

2. **さらに深く調査を続ける**
   - 第2波で3つの不明点を調査
   - 追加で10-15分程度

3. **調査方向を変更する**
   - Git履歴から設計意図を探る
   - 外部ドキュメント・Issueを調査

どの方向で進めますか？
```

---

## タスク管理のベストプラクティス

### TodoWrite の活用

**初期タスク作成**:
```
TodoWrite:
- [ ] 初期セットアップとコードベース分析
- [ ] コンテキスト発見質問（必要に応じて）
- [ ] 第1波: Critical調査タスク
- [ ] 第2波: Important調査タスク
- [ ] 第3波: Nice-to-have調査タスク
- [ ] ユーザーへの回答作成
```

**調査タスクの詳細化**:
```
第1波のタスクを詳細化:
- [ ] SaveManager クラスの詳細調査（SubAgent 1）
- [ ] セーブデータフォーマットの確認（SubAgent 2）
- [ ] エラーハンドリング実装の調査（SubAgent 3）
```

**進捗の更新**:
- SubAgent 起動時: `in_progress` に変更
- SubAgent 完了時: `completed` に変更
- 新たな調査が必要: 新しいタスクを追加

### タスクの粒度

**良い粒度**:
```
- [ ] SaveManager.save() メソッドの実装を調査
- [ ] localStorage への書き込み処理を確認
- [ ] エラー時のリトライロジックを特定
```

**悪い粒度（大きすぎる）**:
```
- [ ] セーブ機能を調査
```

**悪い粒度（小さすぎる）**:
```
- [ ] SaveManager.ts を Glob で検索
- [ ] SaveManager.ts を Read
- [ ] save() メソッドを見つける
- [ ] save() メソッドの引数を確認
```

---

## 回答品質のチェックリスト

回答を提供する前に以下を確認：

### 必須項目

- [ ] 質問に直接答えている
- [ ] すべての主張に根拠（ファイルパス:行番号）がある
- [ ] 推測と事実が明確に区別されている
- [ ] 不明な点は「不明」と明記されている
- [ ] コード例が具体的で実行可能

### 推奨項目

- [ ] アーキテクチャ図やフロー図がある（必要に応じて）
- [ ] 関連リソースへのリンクがある
- [ ] ベストプラクティスとの比較がある
- [ ] 補足・注意点が記載されている

### 避けるべき表現

- ❌ 「おそらく〜だと思います」
- ❌ 「〜あたりにあります」
- ❌ 「いくつかのファイルで〜」
- ❌ 「一般的には〜」（根拠なし）

### 推奨される表現

- ✅ 「src/core/SaveManager.ts:45 で実装されています」
- ✅ 「調査の結果、以下3つのパターンが使われています」
- ✅ 「この部分は実装が見つかりませんでした（検索範囲: src/, lib/）」
- ✅ 「業界標準と比較すると〜（参考: [URL]）」

---

## 実践例

### 例1: 基本的な実装調査

**質問**: 「ゲームのセーブ機能はどう実装されていますか？」

**ワークフロー**:
```
1. フェーズ1: 初期分析
   - Glob: "**/Save*" → SaveManager.ts 発見
   - Read: package.json → localStorage使用を推測

2. フェーズ2: スキップ（質問が明確なため）

3. フェーズ3: 第1波（3個並列）
   SubAgent 1: SaveManager クラス詳細
   SubAgent 2: データフォーマット
   SubAgent 3: エラーハンドリング

   → 70%の情報取得、第2波へ

4. フェーズ3: 第2波（2個並列）
   SubAgent 4: 自動セーブ機能
   SubAgent 5: マイグレーション戦略

   → 十分な情報取得

5. フェーズ4: 回答作成
   - ファイルパス付きで説明
   - フロー図を追加
   - ベストプラクティスと比較
```

### 例2: バグ調査

**質問**: 「セーブボタンを押すとエラーが出ます。なぜですか？」

**ワークフロー**:
```
1. フェーズ1: 初期分析
   - エラーメッセージの確認（ユーザーに依頼）
   - スタックトレースから関連ファイルを特定

2. フェーズ2: コンテキスト発見質問
   - 「エラーは毎回発生しますか？」→ はい
   - 「特定の状況でのみ発生しますか？」→ ゲーム進行後のみ

   → セーブデータのサイズやフォーマットが原因と推測

3. フェーズ3: 第1波（3個並列）
   SubAgent 1: エラーハンドリング実装
   SubAgent 2: データバリデーション
   SubAgent 3: LocalStorage容量チェック

   → 原因特定: データサイズが5MBを超えている

4. フェーズ4: 回答作成
   - 原因: LocalStorageの制限（5MB）超過
   - 場所: SaveManager.ts:67 でエラー
   - 解決策の提案（圧縮、IndexedDB移行等）
```

### 例3: 設計理解

**質問**: 「このプロジェクトのアーキテクチャを教えてください」

**ワークフロー**:
```
1. フェーズ1: 初期分析
   - README.md, ARCHITECTURE.md を確認
   - ディレクトリ構造を分析
   - package.json から技術スタック確認

2. フェーズ2: コンテキスト発見質問
   - 「特に知りたい部分はありますか？」→ データフロー
   - 「フロントエンドとバックエンドの分離状況は？」→ SPA

3. フェーズ3: 第1波（3個並列）
   SubAgent 1: コアモジュールの構成
   SubAgent 2: データフロー（State管理）
   SubAgent 3: 外部依存関係

   → 全体像が把握できた

4. フェーズ4: 回答作成
   - レイヤー構成の図
   - 主要コンポーネントの役割
   - データフローの説明
   - 設計パターンの解説
```

---

## 注意事項

1. **コード編集は行わない**: 質問への回答が目的
2. **推測を事実として扱わない**: 必ず根拠を明示
3. **過度に深く調査しない**: 質問に答えるために必要な範囲で
4. **ユーザーとの対話を重視**: 不明点は素直に質問
5. **TodoWrite で進捗を可視化**: ユーザーが状況を把握できるように

---

## 関連ドキュメント

- `skills/parallel-sessions.md` - 並列実行の一般的なガイド
- `skills/extraction-schema.md` - 情報抽出の手法
- `.claude/CLAUDE.md` - プロジェクト全体のルール
